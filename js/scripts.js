//существует сразу при инициализации скрипта
var first = 1;

//ES6 задание переменной
let second = 2;
// let существует когда код дойдет до {} 
const pi = 3.14;

//типы данных
var number = 5;
    +/-Infinity
    NaN
var string = 'Hello!';
var sym = Symbol();
var boolean = true;
null;
    //ошибка языка
    typeof null //object 
undefined;
var obj = {};
//подтип объекта
typeof function(){} // function


var y = y || 10;
z && console.log(x, y, z);

//тернарный оператор
(num == 50) ? true : false;


//

switch(num) {
    case true:
        console.log('Ok');
        break;
    default:
        console.log(false);
        break;
}

//

while (num < 10 ) {
    console.log(num++);
}

do {
    console.log('Done');
} while (false);

//i++ выполняется после тела цикла
//i видно будет после цикла
for(let i=0; i < 8; i++){
    console.log(i);
}

//прерывание break, продолжение continue

var menu = {
    width: 300,
    height: 200,
    title: "Menu"
  };
  
  for (var key in menu) {
    // этот код будет вызван для каждого свойства объекта
    // ..и выведет имя свойства и его значение
  
    alert( "Ключ: " + key + " значение: " + menu[key] );
  }

// по умолчанию sort сортирует, преобразуя элементы к строке.
//мы передаём в sort() именно саму функцию compareNumeric , без вызова через скобки
// функция, передаваемая sort , должна иметь два аргумента

/*
 Функция должна возвращать:
Положительное значение, если a > b ,
Отрицательное значение, если a < b ,
Если равны – можно 0 , но вообще – не важно, что возвращать, их взаимный порядок не имеет значения.
*/

function compareNumeric(a, b) {
    if (a > b) return 1;
    if (a < b) return -1;
  }
  var arr = [ 1, 2, 15 ];
  arr.sort(compareNumeric);
  alert(arr);  // 1, 2, 15
/*
  Функцию compareNumeric для сравнения элементов‑чисел можно упростить до одной строчки.
  Эта функция вполне подходит для sort , так как возвращает положительное число, если a > b , отрицательное, если наоборот, и 0 , если числа равны.
*/


//Свойство __proto__ доступно во всех браузерах, кроме IE10‑

//Обратим внимание – прототип используется исключительно при чтении. Запись значения, например, rabbit.eats = value или удаление delete rabbit.eats – работает напрямую с объектом.

var animal = {
    eats: true
  };
  var rabbit = {
    jumps: true
  };
  rabbit.__proto__ = animal;


  //Объект, создаваемый при помощи Object.create(null) не имеет прототипа, а значит в нём нет лишних свойств. Для коллекции – как раз то, что надо.


  //Вызов obj.hasOwnProperty(prop) возвращает true , если свойство prop принадлежит самому объекту obj , иначе false .
  var animal = {
    eats: true
  };
  var rabbit = {
    jumps: true,
    __proto__: animal
  };
  alert( rabbit.hasOwnProperty('jumps') ); // true: jumps принадлежит rabbit
  alert( rabbit.hasOwnProperty('eats') ); // false: eats не принадлежит
  
//num.toFixed(n) округляет число num до n знаков после запятой, при необходимости добивает нулями до данной длины и возвращает в виде строки (удобно для форматированного вывода)

var n = 12.345;
alert( n.toFixed(2) ); // "12.35"
alert( n.toFixed(0) ); // "12"
alert( n.toFixed(5) ); // "12.34500"

//Функция isFinite(n) преобразует аргумент к числу и возвращает true , если это не NaN/Infinity/‐Infinity
alert( isFinite(1) ); // true
alert( isFinite(Infinity) ); // false
alert( isFinite(NaN) ); // false


//Единственное исключение – пробельные символы в начале и в конце строки, которые игнорируются
alert( +"  ‐12" ); // ‐12
alert( +" \n34  \n" ); // 34, перевод строки \n является пробельным символом
alert( +"" ); // 0, пустая строка становится нулем
alert( +"1 2" ); // NaN, пробел посередине числа ‐ ошибка
//Аналогичным образом происходит преобразование и в других математических операторах и функциях

//Оператор '+' для таких значений возвратит NaN
alert(+"12px") // NaN
//Для удобного чтения таких значений существует функция parseInt
alert( parseInt('12px') ); // 12

//Функция parseInt и ее аналог parseFloat преобразуют строку символ за символом, пока это возможно
alert( parseInt('12px') ) // 12, ошибка на символе 'p'
alert( parseFloat('12.3.4') ) // 12.3, ошибка на второй точке
alert( parseInt('a123') ); // NaN

//Пустая строка и строка из пробельных символов преобразуются к 0 , поэтому считаются числами.
//Если применить такую проверку не к строке, то могут быть сюрпризы, в частности isNaN посчитает числами значения false, true, null , так как они хотя и не числа, но преобразуются к ним.
alert( isNaN(null) ); //  false ‐ не NaN, т.е. "число"
alert( isNaN("\n  \n") ); //  false ‐ не NaN, т.е. "число"

//точная проверка на число
function isNumeric(n) {
  return !isNaN(parseFloat(n)) && isFinite(n);
}
//Разберёмся, как она работает. Начнём справа. Функция isFinite(n) преобразует аргумент к числу и возвращает true , если это не Infinity/‐Infinity/NaN . Таким образом, правая часть отсеет заведомо не‑числа, но оставит такие значения как true/false/null и пустую строку '' , т.к. они корректно преобразуются в числа. 
//Для их проверки нужна левая часть. Вызов parseFloat(true/false/null/'') вернёт NaN для этих значений. Так устроена функция parseFloat : она преобразует аргумент к строке, т.е. true/false/null становятся "true"/"false"/"null" , а затем считывает из неё число, при этом пустая строка даёт NaN .

// получить 16‑ричное или 2-ное представление числа используется метод toString
var n = 255;
alert( n.toString(16) ); // ff

var n = 4;
alert( n.toString(2) ); // 100


//Округляет до ближайшего целого
alert( Math.floor(3.1) );  // 3
alert( Math.ceil(3.1) );   // 4
alert( Math.round(3.1) );  // 3

//округление с побитовой операцией
alert( 12.3 ^ 0 ); // 12

//округление с заданной точностью
var n = 3.456;
alert( Math.round(n * 100) / 100 ); // 3.456 ‐> 345.6 ‐> 346 ‐> 3.46

//Для красивого вывода чисел
var number = 123456789;
alert( number.toLocaleString() ); // 123 456 789


/*
ИТОГО
Числа могут быть записаны в шестнадцатиричной, восьмеричной системе, а также «научным» способом.
В JavaScript существует числовое значение бесконечность Infinity .
Ошибка вычислений дает NaN .
Арифметические и математические функции преобразуют строку в точности в число, игнорируя начальные и конечные пробелы.
Функции parseInt/parseFloat делают числа из строк, которые начинаются с числа.
Есть четыре способа округления: Math.floor , Math.round , Math.ceil и битовый оператор. Для округления до нужного знака используйте
+n.toFixed(p) или трюк с умножением и делением на 10p
.
Дробные числа дают ошибку вычислений. При необходимости ее можно отсечь округлением до нужного знака.
Случайные числа от 0 до 1 генерируются с помощью Math.random() , остальные – преобразованием из них.
*/

var str = "My\n"; // 3 символа. Третий ‐ перевод строки

//Чтобы получить символ, используйте вызов charAt(позиция) . Первый символ имеет позицию 0
alert( str[0] ); // "Я"

//indexOf возвращает позицию, на которой находится подстрока или ‐1 , если ничего не найдено.
var str = "Widget with id";
alert( str.indexOf("Widget") ); // 0, т.к. "Widget" найден прямо в начале str
alert( str.indexOf("id") ); // 1, т.к. "id" найден, начиная с позиции 1
alert( str.indexOf("widget") ); // ‐1, не найдено, так как поиск учитывает регистр
alert(str.indexOf("id", 2)) // 12, поиск начат с позиции 2

//Также существует аналогичный метод lastIndexOf , который ищет не с начала, а с конца строки

// вызов ~n эквивалентен выражению ‐(n+1)
var str = "Widget";
if (~str.indexOf("get")) {
  alert( 'совпадение есть!' );
}

//Поиск всех вхождений
var str = "Ослик Иа‐Иа посмотрел на виадук"; // ищем в этой строке
var target = "Иа"; // цель поиска
var pos = 0;
while (true) {
  var foundPos = str.indexOf(target, pos);
  if (foundPos == ‐1) break;
  alert( foundPos ); // нашли на этой позиции
  pos = foundPos + 1; // продолжить поиск со следующей
}

var str = "Ослик Иа‐Иа посмотрел на виадук"; // ищем в этой строке
var target = "Иа"; // цель поиска
var pos = ‐1;
while ((pos = str.indexOf(target, pos + 1)) != ‐1) {
  alert( pos );
}

//Метод substring(start, end) возвращает подстроку с позиции start до, но не включая end. substring(start [, end])
var str = "stringify";
alert(str.substring(0,1)); // "s", символы с позиции 0 по 1 не включая 1.

//substr(start [, length])
//slice(start [, end])

//Различие между substring и slice – в том, как они работают с отрицательными и выходящими за границу строки аргументами

//substring(start, end) - Отрицательные аргументы интерпретируются как равные нулю

//slice - Отрицательные значения отсчитываются от конца строки

//Правильное сравнение
var str = "Ёлки";
alert( str.localeCompare("Яблони") ); // ‐1
//Метод str1.localeCompare(str2) возвращает ‐1 , если str1 < str2 , 1 , если str1 > str2 и 0 , если они равны.

/*Строки в JavaScript имеют внутреннюю кодировку Юникод. При написании строки можно использовать специальные символы, например \n и
вставлять юникодные символы по коду.
Мы познакомились со свойством length и методами charAt , toLowerCase/toUpperCase , substring/substr/slice (предпочтителен slice ). Есть и
другие методы, например trim обрезает пробелы с начала и конца строки.
Строки сравниваются побуквенно. Поэтому если число получено в виде строки, то такие числа могут сравниваться некорректно, нужно
преобразовать его к типу number.
При сравнении строк следует иметь в виду, что буквы сравниваются по их кодам. Поэтому большая буква меньше маленькой, а буква ё вообще вне
основного алфавита.
Для правильного сравнения существует целый стандарт ECMA 402. Это не такое простое дело, много языков и много правил. Он поддерживается во
всех современных браузерах, кроме IE10‑, в которых нужна библиотека https://github.com/andyearnshaw/Intl.js/ . Такое сравнение работает через
вызов str1.localeCompare(str2) .
*/

//ОБЪЕКТ
//проверить, есть ли в объекте свойство с определенным ключом

if ("name" in person) {
  alert( "Свойство name существует!" );
}
//Впрочем, чаще используется другой способ – сравнение значения с undefined, но не точен тк свойство может быть с значением underfined .

//Как правило, в коде мы не будем присваивать undefined , чтобы корректно работали обе проверки. А в качестве значения, обозначающего неизвестность и неопределенность, будем использовать null .

//В обоих случаях, имя свойства обязано быть строкой. Если использовано значение другого типа – JavaScript приведет его к строке автоматически.

//Доступ через точку используется, если мы на этапе написания программы уже знаем название свойства. А если оно будет определено по ходу выполнения, например, введено посетителем и записано в переменную, то единственный выбор – квадратные скобки.
var person = {};
person['любимый стиль музыки'] = 'Джаз';

/*Объекты – это ассоциативные массивы с дополнительными возможностями:
Доступ к элементам осуществляется:
Напрямую по ключу obj.prop = 5
Через переменную, в которой хранится ключ:
*/
var key = "prop";
obj[key] = 5
/*Удаление ключей: delete obj.name .
Существование свойства может проверять оператор in : if ("prop" in obj) , как правило, работает и просто сравнение if (obj.prop !==
undefined) .*/

//В переменной, которой присвоен объект, хранится не сам объект, а «адрес его места в памяти», иными словами – «ссылка» на него.
//Внимание: объект – вне переменной. В переменной – лишь «адрес» (ссылка) для него.
var user = { name: "Вася" }; // в переменной ‐ ссылка
var admin = user; // скопировали ссылку
//Получили две переменные, в которых находятся ссылки на один и тот же объект

//Клонирование объектов
var user = {
  name: "Вася",
  age: 30
};
var clone = {}; // новый пустой объект
// скопируем в него все свойства user
for (var key in user) {
  clone[key] = user[key];
}
// теперь clone ‐ полностью независимая копия
clone.name = "Петя"; // поменяли данные в clone
alert( user.name ); // по‐прежнему "Вася"

//Вывод в консоли
var time = {
  year: 2345,
  month: 11,
  day: 10,
  hour: 11,
  minute: 12,
  second: 13,
  microsecond: 123456
}
console.log(time); // (*)
time.microsecond++; // (**)
console.log(time);
time.microsecond++;
console.log(time);
time.microsecond++;
//При «раскрытии» свойств объекта в консоли – браузер всегда выводит их текущие (на момент раскрытия) значения. Так происходит именно потому, что вывод не делает «копию» текущего содержимого, а сохраняет лишь ссылку на объект. Запомните эту особенность консоли, в будущем, при отладке скриптов у вас не раз возникнет подобная ситуация.

/*Объект присваивается и копируется «по ссылке». То есть, в переменной хранится не сам объект а, условно говоря, адрес в памяти, где он
находится.
Если переменная‑объект скопирована или передана в функцию, то копируется именно эта ссылка, а объект остаётся один в памяти.
Это – одно из ключевых отличий объекта от примитива (числа, строки…), который при присвоении как раз копируется «по значению», то есть
полностью.
*/

//Массив – разновидность объекта, которая предназначена для хранения пронумерованных значений

//Одно из применений массива – это очередь. В классическом программировании так называют упорядоченную коллекцию элементов, такую что элементы добавляются в конец, а обрабатываются – с начала.

/*Конец массива
pop
Удаляет последний элемент из массива и возвращает его
push
Добавляет элемент в конец массива
Начало массива
shift
Удаляет из массива первый элемент и возвращает его
unshift
Добавляет элемент в начало массива
Методы push и unshift могут добавлять сразу по несколько элементов
*/
var fruits = ["Яблоко"];
fruits.push("Апельсин", "Персик");
fruits.unshift("Ананас", "Лимон");
//Методы push/pop выполняются быстро, а shift/unshift – медленно

// результат: ["Ананас", "Лимон", "Яблоко", "Апельсин", "Персик"]
alert( fruits );

//Массив – это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length
//Так как это объект, то в функцию он передаётся по ссылке

//Для перебора элементов обычно используется цикл
var arr = ["Яблоко", "Апельсин", "Груша"];
for (var i = 0; i < arr.length; i++) {
  alert( arr[i] );
}

//При уменьшении length массив укорачивается.

var arr = [1, 2, 3, 4, 5];
arr.length = 2; // укоротить до 2 элементов
alert( arr ); // [1, 2]
arr.length = 5; // вернуть length обратно, как было
alert( arr[3] ); // undefined: значения не вернулись

//метод split(s) , который позволяет превратить строку в массив, разбив ее по разделителю s
//Вызов arr.join(str) делает в точности противоположное split

//Код для повторения строки 3 раза:
alert( new Array(4).join("ля") ); // ляляля

//Удаление из массива
var arr = ["Я", "иду", "домой"];
delete arr[1]; // значение с индексом 1 удалено
// теперь arr = ["Я", undefined, "домой"];
alert( arr[1] ); // undefined

//Удалить из середины
//Метод splice – это универсальный раскладной нож для работы с массивами. Умеет все: удалять элементы, вставлять элементы, заменять элементы – по очереди и одновременно.

var arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с позиции 1, удалить 1 элемент
alert( arr ); //  осталось ["Я", "JavaScript"]

var arr = ["Я"                          , "сейчас", "изучаю", "JavaScript"];
// удалить 3 первых элемента и добавить другие вместо них
arr.splice(0, 3, "Мы", "изучаем")
alert( arr ) // теперь ["Мы", "изучаем", "JavaScript"]

//Метод splice также может вставлять элементы без удаления, для этого достаточно установить deleteCount в 0
var arr = ["Я", "изучаю", "JavaScript"];
// с позиции 2
// удалить 0
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"

var arr = [1, 2, 5]
// начиная с позиции индексом ‐1 (перед последним элементом)
// удалить 0 элементов,
// затем вставить числа 3 и 4
arr.splice(‐1, 0, 3, 4);
alert( arr ); // результат: 1,2,3,4,5

//Метод slice(begin, end) копирует участок массива от begin до end , не включая end . Исходный массив при этом не меняется.
var arr = ["Почему", "надо", "учить", "JavaScript"];
var arr2 = arr.slice(1, 3); // элементы 1, 2 (не включая 3)
alert( arr2 ); // надо, учить
var arr2 = arr.slice(‐2); // копировать от 2‐го элемента с конца и дальше
//Синтаксис метода slice одинаков для строк и для массивов. Тем проще его запомнить.

//Метод sort() сортирует массив на месте. 
var arr = [ 1, 2, 15 ];
arr.sort();
alert( arr );  // 1, 15, 2
//Это произошло потому, что по умолчанию sort сортирует, преобразуя элементы к строке.

[1, ‐2, 15, 2, 0, 8].sort(function (a, b) {
  return a ‐ b;
})

//Метод arr.reverse() меняет порядок элементов в массиве на обратный.

//Метод arr.concat(value1, value2, … valueN) создаёт новый массив, в который копируются элементы из arr , а также value1, value2, ... valueN 
var arr = [1, 2];
var newArr = arr.concat([3, 4], 5); // то же самое, что arr.concat(3,4,5)
alert( newArr ); // 1,2,3,4,5

//Метод «arr.indexOf(searchElement[, fromIndex])» возвращает номер элемента searchElement в массиве arr или ‐1 , если его нет. Для поиска используется строгое сравнение === .

/*Методы:
push/pop , shift/unshift , splice – для добавления и удаления элементов.
join/split – для преобразования строки в массив и обратно.
slice – копирует участок массива.
sort – для сортировки массива. Если не передать функцию сравнения – сортирует элементы как строки.
reverse – меняет порядок элементов на обратный.
concat – объединяет массивы.
indexOf/lastIndexOf – возвращают позицию элемента в массиве (не поддерживается в IE8‑).
*/

/*Метод «arr.forEach(callback[, thisArg])» используется для перебора массива.
Он для каждого элемента массива вызывает функцию callback .
Этой функции он передаёт три параметра callback(item, i, arr) :
item – очередной элемент массива.
i – его номер.
arr – массив, который перебирается.*/
var arr = ["Яблоко", "Апельсин", "Груша"];
arr.forEach(function(item, i, arr) {
  alert( i + ": " + item + " (массив:" + arr + ")" );
});

//Метод «arr.filter(callback[, thisArg])» используется для фильтрации массива через функцию. Он создаёт новый массив, в который войдут только те элементы arr , для которых вызов callback(item, i, arr) возвратит true .
var arr = [1, ‐1, 2, ‐2, 3];
var positiveArr = arr.filter(function(number) {
  return number > 0;
});
alert( positiveArr ); // 1,2,3

/*Метод «arr.map(callback[, thisArg])» используется для трансформации массива.
Он создаёт новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr .*/
var names = ['HTML', 'CSS', 'JavaScript'];
var nameLengths = names.map(function(name) {
  return name.length;
});
// получили массив с длинами
alert( nameLengths ); // 4,3,10

/*Эти методы используются для проверки массива.
Метод «arr.every(callback[, thisArg])» возвращает true , если вызов callback вернёт true для каждого элемента arr .
Метод «arr.some(callback[, thisArg])» возвращает true , если вызов callback вернёт true для какого‑нибудь элемента arr .
*/
var arr = [1, ‐1, 2, ‐2, 3];
function isPositive(number) {
  return number > 0;
}
alert( arr.every(isPositive) ); // false, не все положительные
alert( arr.some(isPositive) ); // true, есть хоть одно положительное

/*Метод «arr.reduce(callback[, initialValue])» используется для последовательной обработки каждого элемента массива с сохранением промежуточного результата.
Аргументы функции callback(previousValue, currentItem, index, arr) :
previousValue – последний результат вызова функции, он же «промежуточный результат».
currentItem – текущий элемент массива, элементы перебираются по очереди слева‑направо.
index – номер текущего элемента.
arr – обрабатываемый массив.*/
var arr = [1, 2, 3, 4, 5]
// для каждого элемента массива запустить функцию,
// промежуточный результат передавать первым аргументом далее
var result = arr.reduce(function(sum, current) {
  return sum + current;
}, 0);
alert( result ); // 15

//Как получить значения аргументов, которых нет в списке параметров?
function sayHi() {
  for (var i = 0; i < arguments.length; i++) {
    alert( "Привет, " + arguments[i] );
  }
}
sayHi("Винни", "Пятачок"); // 'Привет, Винни', 'Привет, Пятачок'

//Для объединения нескольких объектов в один:
var vasya = {
  age: 21,
  name: 'Вася',
  surname: 'Петров'
};
var user = {
  isAdmin: false,
  isEmailConfirmed: true
};
var student = {
  university: 'My university'
};
// добавить к vasya свойства из user и student
copy(vasya, user, student);
alert( vasya.isAdmin ); // false
alert( vasya.university ); // My university
//Для создания копии объекта user
// скопирует все свойства в пустой объект
var userClone = copy({}, user);

//Аргументы по умолчанию через ||
function showWarning(width, height, title, contents) {
  width = width || 200; // если не указана width, то width = 200
  height = height || 100; // если нет height, то height = 100
  title = title || "Предупреждение";
  //...
}
// если мы хотим использовать значение по умолчанию только если width === undefined
function showWarning(width, height, title, contents) {
  if (width === undefined) width = 200;
  if (height === undefined) height = 100;
  if (title === undefined) title = "Предупреждение";
  //...
}

//Создает объект Date с текущей датой и временем
var now = new Date();
alert( now );

//Создает объект Date , значение которого равно количеству миллисекунд (1/1000 секунды), прошедших с 1 января 1970 года GMT+0
// 24 часа после 01.01.1970 GMT+0
var Jan02_1970 = new Date(3600 * 24 * 1000);
alert( Jan02_1970 );

/*new Date(year, month, date, hours, minutes, seconds, ms)
Заметим:
Год year должен быть из 4 цифр.
Отсчет месяцев month начинается с нуля 0.*/
new Date(2011, 0, 1, 0, 0, 0, 0); // // 1 января 2011, 00:00:00
new Date(2011, 0, 1); // то же самое, часы/секунды по умолчанию равны 0

//Получение/Установка компонентов даты
// текущая дата
var date = new Date();
// час в текущей временной зоне
alert( date.getHours() );

var today = new Date;
today.setHours(0);
alert( today ); // сегодня, но час изменён на 0

//Преобразование к числу время

var start = new Date; // засекли время
// что‐то сделать
for (var i = 0; i < 100000; i++) {
  var doSomething = i * i * i;
}
var end = new Date; // конец измерения
alert( "Цикл занял " + (end ‐ start) + " ms" );

var date = new Date(2014, 11, 31, 12, 30, 0);
var options = {
  era: 'long',
  year: 'numeric',
  month: 'long',
  day: 'numeric',
  weekday: 'long',
  timezone: 'UTC',
  hour: 'numeric',
  minute: 'numeric',
  second: 'numeric'
};
alert( date.toLocaleString("ru", options) ); // среда, 31 декабря 2014 г. н.э. 12:30:00
alert( date.toLocaleString("en‐US", options) ); // Wednesday, December 31, 2014 Anno Domini 12:30:00 PM


//Глобальными называют переменные и функции, которые не находятся внутри какой‑то функции. То есть, иными словами, если переменная или функция не находятся внутри конструкции function , то они – «глобальные».
// все глобальные переменные и функции являются свойствами специального объекта. В браузере этот объект явно доступен под именем window
var a = 5; // объявление var создаёт свойство window.a
alert( window.a ); // 5
window.a = 5;
alert( a ); // 5

/*Выполнение скрипта происходит в две фазы:
1. На первой фазе происходит инициализация, подготовка к запуску.
Во время инициализации скрипт сканируется на предмет объявления функций вида Function Declaration, а затем – на предмет объявления
переменных var . Каждое такое объявление добавляется в window .
Функции, объявленные как Function Declaration, создаются сразу работающими, а переменные – равными undefined .
2. На второй фазе – собственно, выполнение.
Присваивание ( = ) значений переменных происходит, когда поток выполнения доходит до соответствующей строчки кода, до этого они undefined .*/

//Первый выведет undefined , так как переменная была добавлена в window на фазе инициализации:
alert( a ); // undefined
var a = 5;
//Второй код выведет ошибку, так как переменной ещё не существует
alert( a ); // error, a is not defined
a = 5;

//Фигурные скобки, которые используются в for, while, if , в отличие от объявлений функции, имеют «декоративный» характер
// переменная будет создана до выполнения цикла, на стадии инициализации, и ее значение будет сохранено после окончания цикла.
for (var     i = 0; i < 5; i++) { }

/*Пример
Посмотрим пример, чтобы лучше понимать, как это работает:
При вызове функции:
*/
function sayHi(name) {
  var phrase = "Привет, " + name;
  alert( phrase );
}
sayHi('Вася');
/*1. До выполнения первой строчки её кода, на стадии инициализации, интерпретатор создает пустой объект LexicalEnvironment и заполняет его.
В данном случае туда попадает аргумент name и единственная переменная phrase :*/
function sayHi(name) {
  // LexicalEnvironment = { name: 'Вася', phrase: undefined }
  var phrase = "Привет, " + name;
  alert( phrase );
}
sayHi('Вася');
/*2. Функция выполняется.
Во время выполнения происходит присвоение локальной переменной phrase , то есть, другими словами, присвоение свойству
LexicalEnvironment.phrase нового значения:*/
function sayHi(name) {
  // LexicalEnvironment = { name: 'Вася', phrase: undefined }
  var phrase = "Привет, " + name;
  // LexicalEnvironment = { name: 'Вася', phrase: 'Привет, Вася'}
  alert( phrase );
}
sayHi('Вася');
/*3. В конце выполнения функции объект с переменными обычно выбрасывается и память очищается. В примерах выше так и происходит. Через некоторое время мы рассмотрим более сложные ситуации, при которых объект с переменными сохраняется и после завершения функции.

Из функции мы можем обратиться не только к локальной переменной, но и к внешней*/
var userName = "Вася";
function sayHi() {
  alert( userName ); // "Вася"
}
//Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем LexicalEnvironment , а затем, если её нет – ищет во внешнем объекте переменных. В данном случае им является window .

/*Каждая функция при создании получает ссылку [[Scope]] на объект с переменными, в контексте которого была создана.
При запуске функции создаётся новый объект с переменными LexicalEnvironment . Он получает ссылку на внешний объект переменных из
[[Scope]] .
При поиске переменных он осуществляется сначала в текущем объекте переменных, а потом – по этой ссылке.
*/
/*1. Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment . Каждый запуск функции создает новый
такой объект. На верхнем уровне им является «глобальный объект», в браузере – window .
2. При создании функция получает системное свойство [[Scope]] , которое ссылается на LexicalEnvironment , в котором она была создана.
3. При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а затем во внешних LexicalEnvironment с
места своего «рождения».
*/

//Приём проектирования «Модуль»
//Чтобы проблемы не было, всего‑то нужно, чтобы у скрипта была своя собственная область видимости, чтобы его переменные не попали на страницу. Для этого мы завернём всё его содержимое в функцию, которую тут же запустим.
(function() {
  // глобальная переменная нашего скрипта
  var message = "Привет";
  // функция для вывода этой переменной
  function showMessage() {
    alert( message );
  }
  // выводим сообщение
  showMessage();
})();

/*Общее правило таково:
Если браузер видит function в основном потоке кода – он считает, что это Function Declaration .
Если же function идёт в составе более сложного выражения, то он считает, что это Function Expression */

//ООП
//При объявлении объекта можно указать свойство‑функцию
var user = {
  name: 'Василий',
  sayHi: function() {
    alert( this.name );
  }
};
user.sayHi(); // sayHi в контексте user
//Здесь при выполнении функции user.sayHi() в this будет храниться ссылка на текущий объект user
//Значение this называется контекстом вызова и будет определено в момент вызова функции
var user = { firstName: "Вася" };
var admin = { firstName: "Админ" };
function func() {
  alert( this.firstName );
}
user.f = func;
admin.g = func;
// this равен объекту перед точкой:
user.f(); // Вася
admin.g(); // Админ
admin['g'](); // Админ (не важно, доступ к объекту через точку или квадратные скобки)

//вызова obj.method()
//Он ведь, на самом деле, состоит из двух независимых операций: точка . – получение свойства и скобки () – его вызов (предполагается, что это функция)

//Любой объект в логическом контексте – true , даже если это пустой массив [] или объект {}

//Если в объекте присутствует метод toString , который возвращает примитив, то он используется для преобразования

var user = {
  firstName: 'Василий',
  toString: function() {
    return 'Пользователь ' + this.firstName;
  }
};
alert( user );  // Пользователь Василий

//Для численного преобразования объекта используется метод valueOf , а если его нет – то toString
var room = {
  number: 777,
  valueOf: function() { return this.number; },
  toString: function() { return this.number; }
};
alert( +room );  // 777, вызвался valueOf
delete room.valueOf; // valueOf удалён
alert( +room );  // 777, вызвался toString

// если { ... } находится вне выражений, то это не объект, а блок.
{}[0]   // то же что и: [0]
{} + {} // то же что и: + {}

/*В логическом контексте объект – всегда true .
При строковом преобразовании объекта используется его метод toString . Он должен возвращать примитивное значение, причём не обязательно
именно строку.
Для численного преобразования используется метод valueOf , который также может возвратить любое примитивное значение. У большинства
объектов valueOf не работает (возвращает сам объект и потому игнорируется), при этом для численного преобразования используется toString .
*/
//используют «функции‑конструкторы»
function Animal(name) {
  this.name = name;
  this.canWalk = true;
}
var animal = new Animal("ёжик");
/*1. Создаётся новый пустой объект.
2. Ключевое слово this получает ссылку на этот объект.
3. Функция выполняется. Как правило, она модифицирует this , добавляет методы, свойства.
4. Возвращается this .
*/
//В результате вызова new Animal("ёжик"); получаем такой объект
animal = {
  name: "ёжик",
  canWalk: true
}
//new User(name) создает объект с заданным значением свойства name и методом sayHi
function User(name) {
  this.name = name;
  this.sayHi = function() {
    alert( "Моё имя: " + this.name );

  };
}
var ivan = new User("Иван");
ivan.sayHi(); // Моё имя: Иван
/*
ivan = {
   name: "Иван",
   sayHi: функция
}
*/

/*Объекты могут быть созданы при помощи функций‑конструкторов:
Любая функция может быть вызвана с new , при этом она получает новый пустой объект в качестве this , в который она добавляет свойства. Если
функция не решит возвратить свой объект, то её результатом будет this .
Функции, которые предназначены для создания объектов, называются конструкторами. Их названия пишут с большой буквы, чтобы отличать от
обычных.
*/
//В функции‑конструкторе бывает удобно объявить вспомогательные локальные переменные и вложенные функции, которые будут видны только внутри
function User(firstName, lastName) {
  // вспомогательная переменная
  var phrase = "Привет";
  //  вспомогательная вложенная функция
  function getFullName() {
      return firstName + " " + lastName;
    }
  this.sayHi = function() {
    alert( phrase + ", " + getFullName() ); // использование
  };
}
var vasya = new User("Вася", "Петров");
vasya.sayHi(); // Привет, Вася Петров

//способа явно указать this при помощи методов call и apply 
//Метод call. func.call(context, arg1, arg2, ...)
//Вызов showFullName.call(user) запустит функцию, установив this = user , вот так

function showFullName() {
  alert( this.firstName + " " + this.lastName );
}
var user = {
  firstName: "Василий",
  lastName: "Петров"
};
// функция вызовется с this=user
showFullName.call(user) // "Василий Петров"

//Метод apply
/*Если нам неизвестно, с каким количеством аргументов понадобится вызвать функцию, можно использовать более мощный метод: apply .
Вызов функции при помощи func.apply работает аналогично func.call , но принимает массив аргументов вместо списка.*/
func.call(context, arg1, arg2);
// идентичен вызову
func.apply(context, [arg1, arg2]);

//При помощи apply мы могли бы найти максимум в произвольном массиве, вот так

var arr = [];
arr.push(1);
arr.push(5);
arr.push(2);
// получить максимум из элементов arr
alert( Math.max.apply(null, arr) ); // 5

/*В примере выше мы передали аргументы через массив – второй параметр apply … Но вы, наверное, заметили небольшую странность? В качестве
контекста this был передан null .
Строго говоря, полным эквивалентом вызову Math.max(1,2,3) был бы вызов Math.max.apply(Math, [1,2,3]) . В обоих этих вызовах контекстом будет
объект Math .
Но в данном случае в качестве контекста можно передавать что угодно, поскольку в своей внутренней реализации метод Math.max не использует
this . Действительно, зачем this , если нужно всего лишь выбрать максимальный из аргументов? Вот так, при помощи apply мы получили короткий и
элегантный способ вычислить максимальное значение в массиве!
*/

/*Итого про this
Значение this устанавливается в зависимости от того, как вызвана функция:
При вызове функции как метода*/
obj.func(...)    // this = obj
obj["func"](...)
..
//При обычном вызове

func(...) // this = window (ES3) /undefined (ES5)
//В new
new func() // this = {} (новый объект)
//Явное указание
func.apply(context, args) // this = context (явная передача)
func.call(context, arg1, arg2, ...)

//Конструкция try…catch
try {
  // код ...
} catch (err) {
  // обработка ошибки
}

/*Работает она так:
1. Выполняется код внутри блока try .
2. Если в нём ошибок нет, то блок catch(err) игнорируется, то есть выполнение доходит до конца try и потом прыгает через catch .
3. Если в нём возникнет ошибка, то выполнение try на ней прерывается, и управление прыгает в начало блока catch(err) .
При этом переменная err (можно выбрать и другое название) будет содержать объект ошибки с подробной информацией о произошедшем.*/
//Ошибку, которая произойдёт в коде, запланированном «на будущее», например, в setTimeout , try..catch не поймает

/*В примере выше мы видим объект ошибки. У него есть три основных свойства:
name
Тип ошибки. Например, при обращении к несуществующей переменной: "ReferenceError" .
message
Текстовое сообщение о деталях ошибки.
stack
Везде, кроме IE8‑, есть также свойство stack , которое содержит строку с информацией о последовательности вызовов, которая привела к ошибке.
*/
//Для того, чтобы унифицировать и объединить обработку ошибок парсинга и ошибок в структуре, мы воспользуемся оператором throw . Синтаксис: throw <объект ошибки> .
/*В качестве конструктора ошибок можно использовать встроенный конструктор: new Error(message) или любой другой.
В JavaScript встроен ряд конструкторов для стандартных ошибок: SyntaxError , ReferenceError , RangeError и некоторые другие. Можно использовать
и их, но только чтобы не было путаницы.
*/
var data = '{ "age": 30 }'; // данные неполны
try {
  var user = JSON.parse(data); // <‐‐ выполнится без ошибок
  if (!user.name) {
    throw new SyntaxError("Данные некорректны");
  }
  alert( user.name );
} catch (e) {
  alert( "Извините, в данных ошибка" );
}
/*Ошибку, о которой catch не знает, он не должен обрабатывать.
Такая техника называется «проброс исключения»: в catch(e) мы анализируем объект ошибки, и если он нам не подходит, то делаем throw e .
При этом ошибка «выпадает» из try..catch наружу. Далее она может быть поймана либо внешним блоком try..catch (если есть), либо «повалит»
скрипт.
*/
var data = '{ "name": "Вася", "age": 30 }'; // данные корректны
try {
  var user = JSON.parse(data);
  if (!user.name) {
    throw new SyntaxError("Ошибка в данных");
  }
  blabla(); // произошла непредусмотренная ошибка
  alert( user.name );
} catch (e) {
  if (e.name == "SyntaxError") {
    alert( "Извините, в данных ошибка" );
  } else {
    throw e;
  }
}
//Оборачивание исключений
function ReadError(message, cause) {
  this.message = message;
  this.cause = cause;
  this.name = 'ReadError';
  this.stack = cause.stack;
}
function readData() {
  var data = '{ bad data }';
  try {
    // ...
    JSON.parse(data);
    // ...
  } catch (e) {
    // ...
    if (e.name == 'URIError') {
      throw new ReadError("Ошибка в URI", e);
    } else if (e.name == 'SyntaxError') {
      throw new ReadError("Синтаксическая ошибка в данных", e);
    } else {
      throw e; // пробрасываем
    }
  }
}
try {
  readData();
} catch (e) {
  if (e.name == 'ReadError') {
    alert( e.message );
    alert( e.cause ); // оригинальная ошибка‐причина
  } else {
    throw e;
  }
}
/*Конструкция try..catch может содержать ещё один блок: finally .
Выглядит этот расширенный синтаксис так:*/
try {
  .. пробуем выполнить код ..
} catch(e) {
  .. перехватываем исключение ..
} finally {
  .. выполняем всегда ..
}
/*У него два варианта работы:
1. Если вы ответите на вопрос «Сгенерировать ошибку?» утвердительно, то try ‐> catch ‐> finally .
2. Если ответите отрицательно, то try ‐> finally .
Секцию finally используют, чтобы завершить начатые операции при любом варианте развития событий.
Блок finally срабатывает при любом выходе из try..catch , в том числе и return .
В примере ниже, из try происходит return , но finally получает управление до того, как контроль возвращается во внешний код.*/
function func() {
  try {
    // сразу вернуть значение
    return 1;
  } catch (e) {
    /* ... */
  } finally {
    alert( 'finally' );
  }
}
alert( func() ); // сначала finally, потом 1

//Допустим, ошибка произошла вне блока try..catch или выпала из try..catch наружу, во внешний код. Скрипт упал. В браузере существует специальное свойство window.onerror , если в него записать функцию, то она выполнится и получит в аргументах сообщение ошибки, текущий URL и номер строки, откуда «выпала» ошибка.
<script>
  window.onerror = function(message, url, lineNumber) {
    alert("Поймана ошибка, выпавшая в глобальную область!\n" +
      "Сообщение: " + message + "\n(" + url + ":" + lineNumber + ")");
  };
  function readData() {
    error(); // ой, что‐то не так
  }
  readData();
</script>

//Функциональный способ ООП
//Здесь ООП‑принцип «приватного свойства» реализован через локальные переменные, поэтому и «локальная переменная» и «приватное свойство» – правильные термины, в зависимости от того, с какой точки зрения взглянуть – кода или архитектуры ООП.

/*Итак, мы сделали кофеварку с публичными и приватными методами и заставили их корректно работать.
В терминологии ООП отделение и защита внутреннего интерфейса называется инкапсуляция .
Кратко перечислим бонусы, которые она даёт:
Защита пользователей от выстрела себе в ногу
Представьте, команда разработчиков пользуется кофеваркой. Кофеварка создана фирмой «Лучшие Кофеварки» и, в общем, работает хорошо, но с неё
сняли защитный кожух и, таким образом, внутренний интерфейс стал доступен.
Все разработчики цивилизованны – и пользуются кофеваркой как обычно. Но хитрый Вася решил, что он самый умный, и подкрутил кое‑что внутри
кофеварки, чтобы кофе заваривался покрепче. Вася не знал, что те изменения, которые он произвёл, приведут к тому, что кофеварка испортится через
два дня.
Виноват, разумеется, не только Вася, но и тот, кто снял защитный кожух с кофеварки, и тем самым позволил Васе проводить манипуляции.
В программировании – то же самое. Если пользователь объекта будет менять то, что не рассчитано на изменение снаружи – последствия могут быть
непредсказуемыми.
Удобство в поддержке
Ситуация в программировании сложнее, чем с кофеваркой, т.к. кофеварку один раз купили и всё, а программа может улучшаться и дорабатываться.
При наличии чётко выделенного внешнего интерфейса, разработчик может свободно менять внутренние свойства и методы, без оглядки на
коллег.
Гораздо легче разрабатывать, если знаешь, что ряд методов (все внутренние) можно переименовывать, менять их параметры, и вообще, переписать как
угодно, так как внешний код к ним абсолютно точно не обращается.
Ближайшая аналогия в реальной жизни – это когда выходит «новая версия» кофеварки, которая работает гораздо лучше. Разработчик мог переделать
всё внутри, но пользоваться ей по‑прежнему просто, так как внешний интерфейс сохранён.
*/


/*Для большего контроля над присвоением и чтением значения, вместо свойства делают «функцию‑геттер» и «функцию‑сеттер», геттер возвращает
значение, сеттер – устанавливает.
Если свойство предназначено только для чтения, то может быть только геттер, только для записи – только сеттер.
В качестве альтернативы паре геттер/сеттер применяют единую функцию, которая без аргументов ведёт себя как геттер, а с аргументом – как
сеттер*/

/*Приватные переменные - локальные переменные через var и параметры конструктора
Публичные переменные - через this*/

/* А чему при этом равен this ?… Как вы наверняка помните, в современном стандарте ('use strict') он будет
undefined (в старом – window ), из‑за этого при чтении this.waterAmount возникнет ошибка!
Её можно решить, если вызвать getBoilTime с явным указанием контекста: getBoilTime.call(this)
















